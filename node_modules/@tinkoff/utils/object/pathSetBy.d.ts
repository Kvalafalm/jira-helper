import { ObjBase, Paths, Prop, ReplaceType } from '../typings/types';
interface PathSetBy {
    <K extends Prop, O extends Record<any, any>, R>(path: [K], fn: ObjBase<K, O[K], R>, obj: O): ReplaceType<O, K, R>;
    <K extends Prop, V, R>(path: [K], fn: ObjBase<K, V, R>): <O>(obj: O) => ReplaceType<O, K, R>;
    <K extends Prop>(path: [K]): {
        <O extends Record<any, any>, R>(fn: ObjBase<K, O[K], R>, obj: O): ReplaceType<O, K, R>;
        <V, R>(fn: ObjBase<K, V, R>): <O>(obj: O) => ReplaceType<O, K, R>;
    };
    <O>(path: Paths, fn: ObjBase<Paths, any, any>, obj: O): O;
    (path: Paths, fn: ObjBase<Paths, any, any>): <O>(obj: O) => O;
    (path: Paths): {
        <O>(fn: ObjBase<Paths, any, any>, obj: O): O;
        (fn: ObjBase<Paths, any, any>): <O>(obj: O) => O;
    };
}
declare const _default: PathSetBy;
/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given paths to the result of `fn` call.
 *
 * **Note:** If property in the object is equal to value by reference then function
 * just returns object without changes
 *
 * @param {[String]} paths
 * @param {Function} fn
 * @param {Object} obj
 * @return {Object}
 * @example
 *
 *      pathSetBy(['a', 'b'], x => x+1, {a: { b:1 }}) // => { a: { b: 2 } }
 */
export default _default;
