export declare type Ord = number | string | boolean;
export declare type AnyObj = Record<any, any>;
export declare type AnyArr = any[] | readonly any[];
export declare type AnyObjOrArr = AnyObj | AnyArr;
export declare type ArrBase<T, R> = (value: T, index: number, arr: ArrayLike<T>) => R;
export declare type ObjBase<K extends Prop | Paths, V, R> = (value: V, key: K, obj: Record<K extends Prop ? K : any, V>) => R;
export declare type ObjBaseBy<O extends Record<any, any>, R> = (value: O[keyof O], key: keyof O & string, obj: O) => R;
export declare type ObjOrArrBaseBy<Input extends AnyObjOrArr, R> = Input extends AnyArr ? (value: ArrValues<Input>, key: number, obj: Input) => R : (value: ObjValues<Input>, key: keyof Input, obj: Input) => R;
export declare type CompareFunc<T, R extends Ord> = (a: T, b: T) => R;
export declare type OrdFunc<T, R extends Ord> = (item: T) => R;
export declare type ArrOrdFunc<T, R extends Ord> = ArrBase<T, R>;
export declare type KeyValuePairs<U extends Prop, V> = Array<[U, V]>;
export declare type Void<T = any> = (...a: T[]) => void;
export declare type Void1<T = any> = (a: T) => void;
export declare type ArrVoid<T = any> = ArrBase<T, void>;
export declare type ObjVoid<K extends Prop, V> = ObjBase<K, V, void>;
export declare type Endo<T = any> = (...a: T[]) => T;
export declare type Endo1<T = any> = (a: T) => T;
export declare type Pred<T = any> = (...a: T[]) => boolean;
export declare type Pred1<T = any> = (a: T) => boolean;
export declare type Pred2<U = any, V = any> = (a: U, b: V) => boolean;
export declare type ArrPred<T = any> = ArrBase<T, boolean>;
export declare type ObjPred<K extends Prop, V> = ObjBase<K, V, boolean>;
export declare type ObjPredBy<O> = ObjBaseBy<O, boolean>;
export declare type Func<R = any> = (...args: any[]) => R;
export declare type Func1<R = any> = (arg: any) => R;
export declare type Prop = keyof any;
export declare type Paths = ReadonlyArray<Prop>;
export declare type Pattern = RegExp | string;
export declare type ReplaceType<O, K extends Prop, V> = Pick<O, Exclude<keyof O, K>> & {
    [p in K]: V;
};
/**
 * Obtain the values type of a array
 */
export declare type ArrValues<A extends AnyArr> = A[number];
/**
 * Obtain the values type of a object
 */
export declare type ObjValues<O extends AnyObj> = O[keyof O];
export interface CurriedTypeGuard2<T1, T2, R extends T2> {
    (t1: T1): (t2: T2) => t2 is R;
    (t1: T1, t2: T2): t2 is R;
}
export interface CurriedTypeGuard3<T1, T2, T3, R extends T3> {
    (t1: T1): CurriedTypeGuard2<T2, T3, R>;
    (t1: T1, t2: T2): (t3: T3) => t3 is R;
    (t1: T1, t2: T2, t3: T3): t3 is R;
}
export interface CurriedTypeGuard4<T1, T2, T3, T4, R extends T4> {
    (t1: T1): CurriedTypeGuard3<T2, T3, T4, R>;
    (t1: T1, t2: T2): CurriedTypeGuard2<T3, T4, R>;
    (t1: T1, t2: T2, t3: T3): (t4: T4) => t4 is R;
    (t1: T1, t2: T2, t3: T3, t4: T4): t4 is R;
}
export interface CurriedTypeGuard5<T1, T2, T3, T4, T5, R extends T5> {
    (t1: T1): CurriedTypeGuard4<T2, T3, T4, T5, R>;
    (t1: T1, t2: T2): CurriedTypeGuard3<T3, T4, T5, R>;
    (t1: T1, t2: T2, t3: T3): CurriedTypeGuard2<T4, T5, R>;
    (t1: T1, t2: T2, t3: T3, t4: T4): (t5: T5) => t5 is R;
    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): t5 is R;
}
export interface CurriedTypeGuard6<T1, T2, T3, T4, T5, T6, R extends T6> {
    (t1: T1): CurriedTypeGuard5<T2, T3, T4, T5, T6, R>;
    (t1: T1, t2: T2): CurriedTypeGuard4<T3, T4, T5, T6, R>;
    (t1: T1, t2: T2, t3: T3): CurriedTypeGuard3<T4, T5, T6, R>;
    (t1: T1, t2: T2, t3: T3, t4: T4): CurriedTypeGuard2<T5, T6, R>;
    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): (t6: T6) => t6 is R;
    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6): t6 is R;
}
export interface CurriedFunction2<T1, T2, R> {
    (t1: T1): (t2: T2) => R;
    (t1: T1, t2: T2): R;
}
export interface CurriedFunction3<T1, T2, T3, R> {
    (t1: T1): CurriedFunction2<T2, T3, R>;
    (t1: T1, t2: T2): (t3: T3) => R;
    (t1: T1, t2: T2, t3: T3): R;
}
export interface CurriedFunction4<T1, T2, T3, T4, R> {
    (t1: T1): CurriedFunction3<T2, T3, T4, R>;
    (t1: T1, t2: T2): CurriedFunction2<T3, T4, R>;
    (t1: T1, t2: T2, t3: T3): (t4: T4) => R;
    (t1: T1, t2: T2, t3: T3, t4: T4): R;
}
export interface CurriedFunction5<T1, T2, T3, T4, T5, R> {
    (t1: T1): CurriedFunction4<T2, T3, T4, T5, R>;
    (t1: T1, t2: T2): CurriedFunction3<T3, T4, T5, R>;
    (t1: T1, t2: T2, t3: T3): CurriedFunction2<T4, T5, R>;
    (t1: T1, t2: T2, t3: T3, t4: T4): (t5: T5) => R;
    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;
}
export interface CurriedFunction6<T1, T2, T3, T4, T5, T6, R> {
    (t1: T1): CurriedFunction5<T2, T3, T4, T5, T6, R>;
    (t1: T1, t2: T2): CurriedFunction4<T3, T4, T5, T6, R>;
    (t1: T1, t2: T2, t3: T3): CurriedFunction3<T4, T5, T6, R>;
    (t1: T1, t2: T2, t3: T3, t4: T4): CurriedFunction2<T5, T6, R>;
    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): (t6: T6) => R;
    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6): R;
}
