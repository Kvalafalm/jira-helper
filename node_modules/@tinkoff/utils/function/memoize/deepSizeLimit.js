"use strict";

var memoizeWith = require('./with');

var curryN = require('../curryN');

/**
 * Memoize function with multiply arguments of any type, but it
 * clears cache every time it reaches the limit. Use it when you need
 * deep equality for cache lookup and afraid of memory leak.
 *
 * @param {Number} sizeLimit. Cache size limit
 * @returns {Function} fn
 * @example
 *     const addFlag = obj => ({...obj, flag: true });
 *     const memoize = memoizeDeepSizeLimit(2, addFlag));
 *     memoize({test: 2}); // from addFlag call
 *     memoize({test: 2}); // from cache
 *     memoize({test: 3}); //from addFlag call
 *     memoize({test: 4}); // from addFlag call
 *     memoize({test: 2}); // from addFlag call (memory was cleared)
 */
module.exports = curryN(2, function (maxSize, fn) {
  return memoizeWith(function () {
    return createSizedCache(maxSize);
  }, function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return JSON.stringify(args);
  }, fn);
});

function createSizedCache(maxSize) {
  var cache = new Map();

  cache.set = function () {
    var _Map$prototype$set;

    // flush cache if size reached the limit
    if (cache.size >= maxSize) {
      cache.clear();
    }

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return (_Map$prototype$set = Map.prototype.set).call.apply(_Map$prototype$set, [cache].concat(args));
  };

  return cache;
}