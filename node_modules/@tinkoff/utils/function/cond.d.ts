import { Pred } from '../typings/types';
interface Cond {
    <T, F extends (...args: any[]) => any>(fns: ArrayLike<[Pred<T>, F]>): (...args: T[]) => ReturnType<F>;
}
declare const _default: Cond;
/**
 * Returns a function, `fn`, which encapsulates if/else-if/else logic.
 * `cond` takes a list of [predicate, transform] pairs. All of the arguments
 * to `fn` are applied to each of the predicates in turn until one returns a
 * "truthy" value, at which point `fn` returns the result of applying its
 * arguments to the corresponding transformer. If none of the predicates
 * matches, `fn` returns undefined.
 *
 * @param {[Function, Function]} pairs
 * @return {Function}
 * @example
 *
 *      var fn = cond([
 *        [isEqual(0),   always('water freezes at 0°C')],
 *        [isEqual(100), always('water boils at 100°C')],
 *        [T,           temp => 'nothing special happens at ' + temp + '°C']
 *      ]);
 *      fn(0); //=> 'water freezes at 0°C'
 *      fn(50); //=> 'nothing special happens at 50°C'
 *      fn(100); //=> 'water boils at 100°C'
 */
export default _default;
