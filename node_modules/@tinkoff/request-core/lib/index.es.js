import applyOrReturn from '@tinkoff/utils/function/applyOrReturn';
import once from '@tinkoff/utils/function/once';
import propOr from '@tinkoff/utils/object/propOr';

var Status;
(function (Status) {
    Status["INIT"] = "init";
    Status["COMPLETE"] = "complete";
    Status["ERROR"] = "error";
})(Status || (Status = {}));
var Status$1 = Status;

class Context {
    constructor(initialState) {
        this.state = {
            status: Status$1.INIT,
            request: null,
            response: null,
            error: null,
            ...initialState,
        };
        this.internalMeta = {};
        this.externalMeta = {};
    }
    getState() {
        return this.state;
    }
    setState(stateOrFunc) {
        const newState = applyOrReturn([this.state], stateOrFunc);
        if (newState) {
            this.state = {
                ...this.state,
                ...newState,
            };
        }
    }
    getInternalMeta(metaName) {
        return this.getMeta(metaName, this.internalMeta);
    }
    getExternalMeta(metaName) {
        return this.getMeta(metaName, this.externalMeta);
    }
    updateInternalMeta(metaName, value) {
        this.internalMeta = this.extendMeta(metaName, value, this.internalMeta);
    }
    updateExternalMeta(metaName, value) {
        this.externalMeta = this.extendMeta(metaName, value, this.externalMeta);
    }
    getStatus() {
        return this.state.status;
    }
    getResponse() {
        return this.state.response;
    }
    getRequest() {
        return this.state.request;
    }
    getMeta(metaName, meta = this.externalMeta) {
        if (metaName) {
            return meta[metaName];
        }
        return meta;
    }
    extendMeta(metaName, value, meta = this.externalMeta) {
        if (!value) {
            return;
        }
        return {
            ...meta,
            [metaName]: {
                ...meta[metaName],
                ...value,
            },
        };
    }
}

const DEFAULT_STATUS_TRANSITION = {
    [Status$1.INIT]: Status$1.COMPLETE,
};
const FORWARD = 1;
const BACKWARD = -1;
const requestMaker = function (plugins) {
    const makeRequest = (request) => {
        let i = -1;
        const len = plugins.length;
        const context = new Context();
        context.setState({ request });
        const promise = new Promise((resolve, reject) => {
            const cb = (statusChanged) => {
                const state = context.getState();
                const currentStatus = state.status;
                const nextDefaultStatus = DEFAULT_STATUS_TRANSITION[currentStatus];
                if (statusChanged) {
                    return traversePlugins(currentStatus, BACKWARD);
                }
                if (nextDefaultStatus) {
                    context.setState({
                        status: nextDefaultStatus,
                    });
                    return traversePlugins(nextDefaultStatus, BACKWARD);
                }
                if (currentStatus === Status$1.COMPLETE) {
                    resolve(state.response);
                }
                else {
                    reject(Object.assign(state.error || {}, {
                        url: state.request.url,
                    }));
                }
            };
            const traversePlugins = (event, direction) => {
                const initialStatus = context.getState().status;
                const next = (newState) => {
                    context.setState(newState);
                    const state = context.getState();
                    if (state.status !== initialStatus) {
                        return cb(true);
                    }
                    i += direction;
                    if (i < 0 || i >= len) {
                        return cb(false);
                    }
                    const plugin = plugins[i];
                    const pluginAction = plugin[event];
                    if (!pluginAction || !applyOrReturn([context], propOr('shouldExecute', true, plugin))) {
                        return next();
                    }
                    try {
                        pluginAction(context, once(next), makeRequest);
                    }
                    catch (err) {
                        return next({ status: Status$1.ERROR, error: err });
                    }
                };
                next(); // with no state
            };
            traversePlugins(Status$1.INIT, FORWARD);
        });
        return Object.assign(promise, {
            getState: context.getState.bind(context),
            getInternalMeta: context.getInternalMeta.bind(context),
            getExternalMeta: context.getExternalMeta.bind(context),
        });
    };
    return makeRequest;
};

export { Context, Status$1 as Status, requestMaker as default };
