import prop from '@tinkoff/utils/object/prop';
import AbortController from 'abort-controller';
import propOr from '@tinkoff/utils/object/propOr';
import { Status } from '@tinkoff/request-core';
import { serializeQuery, addQuery, normalizeUrl } from '@tinkoff/request-url-utils';
import fetch from 'node-fetch';
import toLower from '@tinkoff/utils/string/toLower';
import includes from '@tinkoff/utils/array/includes';
import each from '@tinkoff/utils/array/each';
import eachObj from '@tinkoff/utils/object/each';
import isArray from '@tinkoff/utils/is/array';
import isNil from '@tinkoff/utils/is/nil';
import FormData from 'form-data';

const PROTOCOL_HTTP = 'PROTOCOL_HTTP';
const HttpMethods = {
    GET: 'GET',
    POST: 'POST',
    PUT: 'PUT',
    DELETE: 'DELETE',
    HEAD: 'HEAD',
    PATCH: 'PATCH',
};
const REQUEST_TYPES = {
    html: 'text/html',
    json: 'application/json',
    xml: 'text/xml',
    urlencoded: 'application/x-www-form-urlencoded',
    form: 'application/x-www-form-urlencoded',
    'form-data': 'application/x-www-form-urlencoded',
    'multipart/form-data': '',
};

const getSetCookieHeader = (headers) => {
    if (typeof window === 'undefined') {
        return headers.raw()['set-cookie']; // node-fetch specific api, see https://github.com/bitinn/node-fetch#extract-set-cookie-header
    }
    return []; // browser doesn't provide set-cookie header, just return empty array for compatibility
};
// TODO: when some plugins (for example cache) break flow, plugin-http won't be called and meta will be empty
const _getResponse = (request) => {
    const meta = request.getInternalMeta(PROTOCOL_HTTP);
    return meta && meta.response;
};
const _getHeaders = (request) => {
    return prop('headers', _getResponse(request));
};
const getHeaders = (request) => {
    const headers = _getHeaders(request);
    const result = {};
    if (headers) {
        headers.forEach((v, k) => {
            if (k === 'set-cookie') {
                result[k] = getSetCookieHeader(headers);
            }
            else {
                result[k] = v;
            }
        });
    }
    return result;
};
const getHeader = (request, header) => {
    const headers = _getHeaders(request);
    if (headers) {
        if (header === 'set-cookie') {
            return getSetCookieHeader(headers);
        }
        return headers.get(header);
    }
};
const getStatus = (request) => {
    return prop('status', _getResponse(request));
};
const abort = (request) => {
    const meta = request.getInternalMeta(PROTOCOL_HTTP);
    return meta && meta.requestAbort();
};

const isHttpError = (error) => {
    return error.code === 'ERR_HTTP_ERROR';
};
const isTimeoutError = (error) => {
    return error.code === 'ERR_HTTP_REQUEST_TIMEOUT';
};
const isAbortError = (error) => {
    return error.code === 'ABORT_ERR';
};
const isNetworkFail = (error) => {
    return isTimeoutError(error) || (isHttpError(error) && !error.status);
};
const isServerError = (error) => {
    return isHttpError(error) && error.status >= 500;
};

const serialize = (type, payload, querySerializer = serializeQuery) => {
    switch (type) {
        case 'form':
        case 'urlencoded':
        case 'form-data':
            return querySerializer(payload);
        case 'json':
            return JSON.stringify(payload);
        default:
            return payload;
    }
};

var parse = (res) => {
    const type = toLower(res.headers.get('content-type') || '');
    if (includes('application/json', type)) {
        return res.json();
    }
    if (includes('application/octet-stream', type)) {
        return res.arrayBuffer();
    }
    return res.text();
};

var createForm = (payload, attaches = []) => {
    const form = new FormData();
    const setField = (value, name) => {
        if (isArray(value)) {
            return each((f) => setField(f, name), value);
        }
        if (isNil(value)) {
            return;
        }
        form.append(name, value);
    };
    eachObj(setField, payload);
    attaches.forEach((file) => {
        if (!(file instanceof window.Blob)) {
            return;
        }
        const fileUploadName = file.uploadName || file.name;
        const fileFieldName = file.fieldName || 'file';
        form.append(fileFieldName, file, encodeURIComponent(fileUploadName));
    });
    return form;
};

class TimeoutError extends Error {
    constructor() {
        super(...arguments);
        this.code = 'ERR_HTTP_REQUEST_TIMEOUT';
        this.message = 'Request timed out';
    }
}
class AbortError extends Error {
    constructor() {
        super(...arguments);
        this.code = 'ABORT_ERR';
    }
}

const isBrowser = typeof window !== 'undefined';
/**
 * Makes http/https request.
 * Uses `node-fetch` library.
 *
 * requestParams:
 *      httpMethod {string} [='get']
 *      url {string}
 *      query {object}
 *      queryNoCache {object} - query which wont be used in generating cache key
 *      headers {object}
 *      type {string} [='form']
 *      payload {object}
 *      attaches {array}
 *      timeout {number}
 *      credentials {string}
 *      abortPromise {Promise}
 *      signal {AbortSignal}
 *
 * @param {agent} [agent = Agent] set custom http in node js. The browser ignores this parameter.
 * @param {QuerySerializer} querySerializer function that will be used instead of default value to serialize query strings in url
 * @return {{init: init}}
 */
var http = ({ agent, querySerializer, } = {}) => {
    let customAgent;
    if (!isBrowser && agent) {
        customAgent = (parsedUrl) => {
            if (parsedUrl.protocol === 'http:') {
                return agent.http;
            }
            return agent.https;
        };
    }
    return {
        init: (context, next) => {
            const { httpMethod = HttpMethods.GET, url, query, queryNoCache, headers, type = 'form', payload, attaches = [], timeout, credentials, withCredentials, abortPromise, responseType, signal: argSignal, } = context.getRequest();
            let ended = false;
            // should be uppercased by spec
            // https://fetch.spec.whatwg.org/#concept-method-normalize
            const method = httpMethod.toUpperCase();
            const noBody = method === HttpMethods.GET || method === HttpMethods.HEAD;
            let body;
            let formHeaders;
            if (attaches.length) {
                body = createForm(payload, isBrowser ? attaches : []);
                formHeaders = body.getHeaders && body.getHeaders();
            }
            else {
                const contentType = propOr(type, type, REQUEST_TYPES);
                formHeaders = contentType ? { 'Content-type': contentType } : {};
                if (!noBody) {
                    body = serialize(type, payload, querySerializer);
                }
            }
            let timer;
            let signal;
            if (AbortController) {
                const controller = new AbortController();
                signal = controller.signal;
                const abort = (abortOptions) => {
                    if (ended) {
                        return;
                    }
                    ended = true;
                    controller.abort();
                    next({
                        status: Status.ERROR,
                        error: abortOptions instanceof Error
                            ? abortOptions
                            : Object.assign(new AbortError(), {
                                abortOptions: abortOptions || {},
                            }),
                    });
                };
                if (abortPromise) {
                    abortPromise.then(abort);
                }
                if (timeout) {
                    timer = setTimeout(() => {
                        abort(new TimeoutError());
                    }, timeout);
                }
                context.updateInternalMeta(PROTOCOL_HTTP, {
                    requestAbort: abort,
                });
                if (argSignal) {
                    if (argSignal.aborted) {
                        abort();
                    }
                    else {
                        argSignal.addEventListener('abort', () => {
                            abort();
                        });
                    }
                }
            }
            else {
                if (timeout) {
                    timer = setTimeout(() => {
                        next({
                            status: Status.ERROR,
                            error: new TimeoutError(),
                        });
                        ended = true;
                    }, timeout);
                }
            }
            let response;
            let responseBody;
            fetch(addQuery(normalizeUrl(url), {
                ...(noBody ? payload : {}),
                ...queryNoCache,
                ...query,
            }, querySerializer), {
                signal,
                method,
                headers: { ...formHeaders, ...headers },
                agent: customAgent,
                credentials: credentials !== null && credentials !== void 0 ? credentials : (withCredentials ? 'include' : 'same-origin'),
                body,
                timeout,
            })
                .then((resp) => {
                response = resp;
                context.updateInternalMeta(PROTOCOL_HTTP, {
                    response,
                });
                if (response[responseType]) {
                    return response[responseType]();
                }
                return parse(response);
            })
                .then((body) => {
                if (ended) {
                    return;
                }
                responseBody = body;
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
                next({
                    status: Status.COMPLETE,
                    response: responseBody,
                });
            })
                .catch((err) => {
                if (ended) {
                    return;
                }
                if (err && typeof err.type === 'string' && /timeout/.test(err.type)) {
                    return next({
                        status: Status.ERROR,
                        error: new TimeoutError(),
                    });
                }
                next({
                    status: Status.ERROR,
                    error: Object.assign(err, {
                        code: 'ERR_HTTP_ERROR',
                        status: response && response.status,
                        body: responseBody,
                    }),
                    response: responseBody,
                });
            })
                .then(() => {
                ended = true;
                timer && clearTimeout(timer);
            });
        },
    };
};

export { HttpMethods, _getResponse, abort, http as default, getHeader, getHeaders, getStatus, isAbortError, isHttpError, isNetworkFail, isServerError, isTimeoutError };
